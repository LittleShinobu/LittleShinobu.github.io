# 学习计划（TODO）

## 0. 参考资料《重要资源》

[Java后端实习生面经总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/161853466)
[Java 实习生（月薪 3k-5k 水平）应具备哪些知识、能力](https://www.zhihu.com/question/266278003/answer/378735816?utm_source=wechat_session&utm_medium=social&utm_oi=803555606832222208&utm_content=group3_Answer&utm_campaign=shareopn)



[[面经\]分享一下这两个月找暑期实习的经历吧 - 0xFFFF](https://0xffff.one/d/567-mian-jing-fen-xiang-yi-xia-zhe-liang-ge-yue-zhao-shu-qi-shi-xi-de-jing-li-ba/2)

[22届春招暑期实习后端开发面经 - 0xFFFF](https://0xffff.one/d/986-22-jie-chun-zhao-shu-qi-shi-xi-hou-duan-kai-fa-mian-jing)



数据结构可视化：[Data Structure Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)



## 1.题目合集

https://blog.csdn.net/qq_41701956/article/details/110119625



## TODO

方法：现在这里写学习的TODO，然后在后面补充详细内容



**重要紧急**：

1. java基础：
   1. 进程通信啥的（高并发）
   
   1. 消息队列
   
      



2. Spring
   1. IOC
   2. AOP
   3. **看springboot2源码解析！！！**



3.  mybatis(-plus)知识补充



5. sql
   1. **数据库优化**
   2. sql语句学习






**重要不紧急**

1. 微服务和分布式



# 知识补充

## 0. 导言

包括面试知识、项目知识、等等



##  1.一些疑问

哈希值是不是根据key算出来的，那么如果key变了，hash就会改变，那么为什么会出现哈希碰撞？
因为hash不一定会不同，而且那个碰撞是基于hash值取余得来的，碰撞概率更高；

红黑树：源码





## 1.1java基础：

参考资料：

[【千锋】最新版 Java集合框架详解 通俗易懂_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1zD4y1Q7Fw)

[Java集合 Collection、Set、Map、泛型 简要笔记 - CoderZjz - 博客园 (cnblogs.com)](https://www.cnblogs.com/coderzjz/p/13587167.html)




### 1.1.1 ArrayList（源码）

[ ArrayList源码分析（基于JDK8）_Fighter168的博客-CSDN博客](https://blog.csdn.net/fighterandknight/article/details/61240861)

特点：有序，基于数组

原理：实现接口list，基于存储Object的数组，然后向上转型，默认容量为10

add原理：

一个参数的方法：队尾加
俩参数：指定位置加，通过数组赋值的方式

```java
System.arraycopy(elementData, index, elementData, index + 1, size - index);  	//相当于原数组从index往后挪一个
```



空间溢出处理：扩大1.5倍
```java
int arg1 = this.elementData.length;
		int arg2 = arg1 + (arg1 >> 1);
```

indexOf：逐个遍历

remove：往前挪



### 1.1.2 Map

重点讲HashMap

特点：
读写快速；
**数组+红黑树/链表实现（链表长度大于8转换成红黑树）**

入门版：[最通俗易懂搞定HashMap的底层原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/79507868)

进阶版：[HashMap原理详解，看不懂算我输（附面试题） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/127147909)

>存储结构：哈希表（数组+链表+红黑树）
>
>存储过程（重复依据）
>
>1. 根据hashCode计算保存的位置，如果位置为空，直接保存，若不为空，进行第二步
>2. 再执行equals方法，如果equals为true，则认为是重复，否则形成链表
>
>特点
>
>- 基于HashCode计算元素存放位置
>  - 利用31这个质数，减少散列冲突
>    - 31提高执行效率 `31 * i = (i << 5) - i` 转为移位操作
>  - 当存入元素的哈希码相同时，会调用equals进行确认，如果结果为true，则拒绝后者存入
>
>新建集合 `HashSet<String> hashSet = new HashSet<String>();`
>
>添加元素 `hashSet.add( );`
>
>删除元素 `hashSet.remove( );`
>
>遍历操作
>
> 1. 增强for `for( type type : hashSet)`
>
> 2. 迭代器 `Iterator<String> it = hashSet.iterator( );`
>
>判断 `hashSet.contains( );` `hashSet.isEmpty();`





### 1.1.3 java递归/回溯的返回机制（待解答）

就是多重return如何处理



### 1.1.4 反射







### 1.1.5 多线程（不熟）《有专门的笔记》

详情见专门的笔记

附：面试题如下：[Java面试题|多线程22道必看面试题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/94325810)

1.创建线程的方法

1. 继承Thread类：重写run()，然后start()

   1. 不建议使用：以防止OOP单继承的局限

2. 实现Runnable接口：实现run()，然后start()--【有代理模式的意思】
   ```java
   TestRunnable testThread = new TestRunnable();
   Thread thread = new Thread(testThread);
   thread.start();
   
   //和下面效果一样
   new Thread(testThread).start();
   new Thread(testThread).start();
   new Thread(testThread).start();
   ```

   1. 推荐使用，可以一个runnable给多个线程共用
   2. ![image-20220531161433118](https://s2.loli.net/2022/06/08/OSVoRHEUrLJ3Zag.png)
   3. 一份资源，多个代理





### 1.1.6 函数式接口

就是只有一个方法的接口；

用lambda、匿名内部类等等可以实现该接口



2.线程同步问题-->银行家算法



[ThreadLocal，一篇文章就够了 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/102744180)

这个我不知道会想怎么考，很少用
线程通信





### 1.1.7 异常

https://blog.csdn.net/qq635785620/article/details/7781026





### 1.1.x  JVM《难点》

[Java基础：Java虚拟机(JVM) - CieloSun - 博客园 (cnblogs.com)](https://www.cnblogs.com/cielosun/p/6622983.html)
JVM主要包括：

+ 程序计数器(Program Counter)，
+ Java堆(Heap)，Java虚拟机栈(Stack)，
+ 本地方法栈(Native Stack)，
+ 方法区(Method Area)







基础入门文章版：[Java JVM 运行机制及基本原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25713880)
视频版：看[【狂神说Java】JVM快速入门篇_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1iJ411d7jS)



## 1.2 servlet

《也是不熟，但是重点》

### 1.2.1 HttpServletRequest





### 1.2.2 Filter





## 2.Spring

1. IOC
2. AOP
3. **看springboot2源码解析！！！**



## 2.5 SpringBoot2





## 3. mybatis(-plus)知识补充







## 4. 数据库

参考资料：[事务ACID理解_dengjili的博客-CSDN博客_acid](https://blog.csdn.net/dengjili/article/details/82468576)

4.1 ACID理解

>Atomicity: 原子性----基本操作要一起成功或者失败
>Consistency：一致性----（类似于质量守恒）
>Isolation: 隔离性----（并发访问，各个线程互不影响）
>Durability：持久性----（词根：dur，事务提交后改变时永久的）



### 4.2 **隔离性级别**

[MySQL 中隔离级别 RC 与 RR 的区别 - digdeep - 博客园 (cnblogs.com)](https://www.cnblogs.com/digdeep/p/4968453.html)

>**脏读**：指一个事务读取了另外一个事务未提交的数据。
>
>**不可重复读**：在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误，只是某些场合不对）
>
>**虚读(幻读)**：是指在一个事务内读取到了别的事务插入的数据，导致前后读取数量总量不一致。
>（一般是行影响，如下图所示：多了一行）

set transaction isolation level 设置事务隔离级别
select @@tx_isolation 查询当前事务隔离级别

设置	描述
Serializable	可避免脏读、不可重复读、虚读情况的发生。（**串行化**）
Repeatable read	可避免脏读、不可重复读情况的发生。（可**重复读**）
Read committed	可避免脏读情况发生（读**已提交**）。
Read uncommitted	最低级别，以上情况均无法保证。(**读未提交**)



### 4.3 数据库优化

[超全面常用的数据库优化方案 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/65058992)







### 4.x nosql

（redis等）



## 5.数据结构/算法

经典100题：[(24条消息) Leetcode刷题指南和top100题目_lingpy的博客-CSDN博客_leetcode高频100题](https://blog.csdn.net/lingpy/article/details/88085446)

数据结构可视化：[Data Structure Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

### 5.1 树

####  5.1.1 平衡树

[什么是平衡二叉树（AVL） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/56066942)
[(67 封私信 / 80 条消息) 平衡二叉树 - 搜索结果 - 知乎 (zhihu.com)](https://www.zhihu.com/search?type=content&q=平衡二叉树)（左旋和右旋）



如何理解左旋和右旋：

以左旋为例，**就是把根节点的右子树提上来**，将其变成根节点，然后原来的右子树的左子树，把它父节点指向原来的根结点，因为不指过去的话就有三条线啦。

![这里写图片描述](https://s2.loli.net/2022/06/08/poduOlfrV9eYIQP.gif)

右旋动图

![这里写图片描述](https://s2.loli.net/2022/06/08/HutdDa5PRAm7Zlv.gif)









234树：[234树的由来及其红黑树 - 掘金 (juejin.cn)](https://juejin.cn/post/6975534277450530853)

#### 5.1.2 [图解：什么是红黑树？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/273829162)



### 5.2 哈希表等

[哈希表（散列表）原理详解 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1432801)

最通俗易懂：[来吧！一文彻底搞定哈希表！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95156642)





### 5.3 栈

两个栈实现队列的时间最优解：
https://blog.csdn.net/weixin_42671974/article/details/118789178

基本上时每次pop的时候，（如果有）都从缓存的stack2中pop出来，就是说从stack1中push到2的数据不用回来。





### 5.4 回溯

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

```java
class Solution {
   public List<String> letterCombinations(String digits) {
        if(digits.length()==0)return new LinkedList<String>();

        //全排列问题
        //bfs

        HashMap<Character, String> stringHashMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};

        List<String> list=new LinkedList();
        list.add("");
//        list.add(String.valueOf(digits.charAt(0)));
        for(int t=0;t<digits.length();t++){
            int listSize = list.size();
            for (int n=0;n<listSize;n++){
                String origin = list.remove(0);
                String str = stringHashMap.get(digits.charAt(t));

                for(int i=0;i<str.length();i++){
                    //拼接
                    list.add(origin+str.charAt(i));
                }
            }
            
        }
        return list;
    }
}
```



### 5.5 广搜/深搜（图算法）

dfs经典题目：计算岛屿数量
[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/)：变种：[130. 被围绕的区域 - 力扣（LeetCode）](https://leetcode.cn/problems/surrounded-regions/submissions/)





### 5.6 TOP-K问题

解法：

1. 直接快排
2. 对前k使用最小堆构建，然后对[k+1,n]遍历
3. 随机选择算法（跟二分查找有点像）

现在重点讲partition算法：

[面试题 17.14. 最小K个数 - 力扣（LeetCode）](https://leetcode.cn/problems/smallest-k-lcci/submissions/)

```java
public int[] smallestK(int[] arr, int k) {
        int len=arr.length;
        int []ans=new int[k];
        if(len==0)return ans;
        partition(0,len-1,arr,k);
        for(int i=0;i<k;i++){
            ans[i]=arr[i];
        }
        return ans;
    }

    public void partition(int left,int right,int []arr,int k){
        if(left>right)return;
        int pivot=arr[left];
        int i=left,j=right;
        while (i < j) {
            while (i < j && arr[j] >= pivot) j--;
            while (i < j && arr[i] <= pivot) i++;
            swap(arr, i, j);
        }
        swap(arr, i, left);
        if (i > k) partition(left, i - 1,arr, k);
        if (i < k) partition(i + 1, right,arr, k);
       
    }


    public void swap(int[] arr, int l, int r){
        int tmp = arr[l];
        arr[l] = arr[r];
        arr[r] = tmp;
    }
```







### 5.7 排序

快排[(24条消息) 快速排序(动画示例)_Kimi-zhang的博客-CSDN博客_快速排序动画](https://blog.csdn.net/weixin_42437295/article/details/90771962)

分治排序



## 6. 操作系统

### 6.1 锁



#### 6.1.1 死琐条件

- 互斥：资源不能被共享，只能由一个进程使用。
- 请求与保持：进程已获得了一些资源，但因请求其它资源被阻塞时，对已获得的资源保持不放。
- 不可剥夺：有些系统资源是不可抢占的，当某个进程已获得这种资源后，系统不能强行收回，只能由进程使用完时自己释放。

+ 循环等待：若干个进程形成环形链，每个都占用对方申请的下一个资源。



#### 6.1.2 如何预防

因为前三个时独占锁的特性，所以着手破坏**循环等待**这一条件，就可以预防死锁。

银行家算法：[操作系统——银行家算法（Banker's Algorithm） - 王陸 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wkfvawl/p/11929508.html)





## 7 设计模式

工厂模式

[【狂神说Java】通俗易懂的23种设计模式教学（停更）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1mc411h719)



AOP实现原理：动态代理模式

三大要素：接口，实现类，代理程序

![image-20220531163527101](https://s2.loli.net/2022/06/08/oxd8hVpKlYznW2D.png)



## 8 计算机网络

必考：

围绕TCP/UDP的：TCP三次握手和四次挥手、拥塞控制、超时重传等等

HTTP





重要：





## 9 Linux







# 业务知识

## 1. 单点登录

[什么是单点登录（SSO） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/66037342)







# 面试准备



## 0. 注意事项

### 0.1 炮灰警告

[如何判断招聘公司不招人？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/355351935/answer/903185360)

如下岗位可以无视了，必定失败

1. 常年招聘-->就是用来宣传公司和摆放的
2. 要求不明确
3. 有“急急急！！！”“急聘！”“【五险一金朝九晚五】营销/文员”“【带薪培训+底薪xx+高提成+急！】销售”字眼
4. 风马牛不相及的两个及更多职位写在一起的
5. ...etc（自行查看参考资料）



反正要事先跟hr沟通！！！



## 1. 简历









## 2. 自我介绍





## 3. 要问的问题





